# 電子オルゴール
## 製作
### 部品
#### 一個で一個
- [磁気スピーカ ¥50](https://akizukidenshi.com/catalog/g/gP-10129/)
- [タクトスイッチ ¥10](https://akizukidenshi.com/catalog/g/gP-03647/)
- [抵抗内蔵LED ¥12 (10個入り)](https://akizukidenshi.com/catalog/g/gI-06245/)
- [電池 ¥40 (5個入り)](https://akizukidenshi.com/catalog/g/gB-05694/)
- [ATTiny85 ¥200](https://akizukidenshi.com/catalog/g/gI-09573/)
- [ブレッドボード ¥130](https://akizukidenshi.com/catalog/g/gP-05155/)


#### 一個で複数個
- [Arduino UNO ¥3630](https://akizukidenshi.com/catalog/g/gM-07385/)
- [スズメッキ線 ¥230](https://akizukidenshi.com/catalog/g/gP-02220/)
- [単芯導線 ¥620](https://akizukidenshi.com/catalog/g/gP-08996/)
- PC

### プログラムの書き込み
1. Arduino IDEをPCにインストールして各種設定をする
	1. [arduino.cc](https://www.arduino.cc/en/software)からPCに合ったArduino IDEをダウンロード
	1. Arduino IDEの`ファイル>設定`を開いて(`Ctrl+,`)
		- `より詳細な情報を表示する>書き込み`にチェックを入れる
		- `追加のボードマネージャのURL`に`http://drazzy.com/package_drazzy.com_index.json`をコピペ
	1. `ツール>ボード>ボードマネージャ...`でATTinyCoreを検索してインストール
1. Arduino UNOをArduino ISP化する
	1. Arduino IDEの `ファイル>スケッチ例>Arduino ISP>Arduino ISP` を選択
	1. Arduino UNOをPCに繋いで左上`→`ボタンを押す
	1. Arduino UNOは繋いだままでOK
1. **Arduino UNOとATTiny85を結線**
	- 困ったら[ATTiny 5seriesのデータシートの日本語訳](https://avr.jp/user/DS/PDF/tiny45.pdf)を参照すると良い
	- データシート2枚目にATTiny85のピンの図がある
	- ATTiny85はブレッドボード中央に刺してジャンパ線でArduino UNOと以下の通り結線
		- UNO	t85
		- ===	===
		- 10	PB5
		- 11	PB0
		- 12	PB1
		- 13	PB2
		- 5V	VCC
		- GND	GND
1. avrdudeとcfgファイルのパスを取得
	- `ファイル>スケッチ例>Basic>Blink`を開く
	- `ツール>ボード>ATTinyCore>ATTiny 25/45/85 (No Bootloader)`を選択
	- `ツール>ポート>~~(Arduino UNO)`を選択
		- `~~`部分がポートを表す文字列
		- Windowsだと`COM1`とか
		- Macだと`/dev/tty.usbmodem1234`とか
		- あとで使うのでここで見れることを覚えておく
	- `ツール>書き込み装置>Arduino as ISP`を選択
	- `スケッチ>書き込み装置を使って書き込む`
	- 出てきたログの一番上に`~/avrdude`と`~/avrdude.cfg`で終わる行があるのでそのパスをコピー
	- 適当なテキストファイルにペーストして保存しておく
1. ATTiny85の設定
	- ターミナルを開いて(`Win+X I`)
		```
		<~~/avrdude> -C <~~/avrdude.cfg> -v -p t85 -c avrisp -P <ポート> -b 19200 -U lfuse:w:0xf1:m -U hfuse:w:0xdf:m -U efuse:w:0xfe:m
		```
		を実行
		- `< ~~ >`部分はそれぞれメモしたパスとポートに書き換える
1. **電子オルゴール本体のプログラムを書き込む**
	- 用意したスケッチを開いて`スケッチ>書き込み装置を使って書き込む`

- 以降プログラムを書き換える際は太字の項のみでOK
	
## 解説
### 回路概要
#### 磁気スピーカー
コイルと磁石を用いた一般的なスピーカーである  
電子工作では物体に電圧をかけると僅かに変形する所謂ピエゾ効果を用いた圧電スピーカーを用いることが多いが、音質の面で圧倒的に不利なので今回は小型の磁気スピーカーを用いた
#### タクトスイッチ
押下している間のみ通電するタイプのスイッチ  
電子工作でよく使われる
#### 抵抗内蔵LED
LEDは少ない電流で発光する半導体である  
半導体であるため、一般的なオームの法則(V=IR)は成り立たない  
電流を流しすぎると焼き切れてしまうため、電流制限のために抵抗を直列に繋ぐのが一般的である  
今回は部品点数削減のため抵抗を内蔵したタイプのLEDを用いた
#### ボタン電池 CR2032
薄型リモコン等によく使われる直径20mm厚さ3.2mmのリチウム電池である  
定格電圧は3Vで大電流には向かないが容量が大きい  
今回はサイズと入手性の良さからこれを用いた
#### ATTiny85
小型のコンピュータ  
部品の制御と音楽データの再生を担う
選定理由は後述
以下t85と表記

### ATTiny85概要
#### 内蔵8MHzクロック
内蔵するCPUやその他全ての機能を動かすためのクロック  
このクロックを基準に全ての機能が足並み揃えて動作する  
周波数はCPUの性能や消費電力に大きく影響する  
一般的に周波数が高いほど高性能大消費になる
	
#### PLL
クロックを8倍速した64MHzのクロックを生成する機能  
ここで生成したクロックはCPUや高速タイマーなどの一部機能で通常のクロックの代わりに使用できる
	
#### 汎用8bitタイマー/カウンター TCNT0
TCNTはTimer CouNTerの略  
主に時間を測るために用いるタイマー  
時間が関係するほぼ全ての機能にタイマーが必要  
0から最大で255まで数えることができ、2^N(N=0~14)クロック毎に1の増減が可能  
最大値まで数えた後は幾つかの動作パターンが用意されており、それらを切り替えて使うことができるが一般的には0に戻る  
別で保存した値と比較することで出力のON OFFを切り替えることができる

#### 高速8bitタイマー/カウンター TCNT1
こちらはTCNT0から動作パターンを減らした代わりに、クロック元にPLLを選択できるため高速な動作が可能なタイマー

#### スリープ機能
何もしない場合にCPUを含めて様々な機能を止めることで消費電力を抑えることができる  
いくつかのモードがある

#### その他特徴
- 加算減算しかできないので乗算除算は非常に遅いがビットシフトを使って2^Nは高速に計算できる

### プログラム概要
まずよく使う基本的な機能は別個で用意する
- WAIT 最大32us=0.000032秒待つ (32usに1回のみ処理可能)
- WAIT255 32*255us=0.00816秒待つ
- PB0_PUSHED 0番ピンに繋いだスイッチが押されているか否かを返す

次にプログラム全体の機能を分割すると

- sleep 使わない時は省電力モードに移行する 
- blink LEDを点滅させる
- play 音楽を再生する
	- 繰り返し
		- 楽譜を読み込む
		- 波形を生成する(毎秒20000回)
		- 音を減衰させる
		- ボタンが押されたら止める
- その他初期設定
#### sleep
スリープ機能を使う  
スリープから復帰する条件の設定を行った後モードを指定してスリープする  
スリープから復帰したらスリープする前に変更した設定を元に戻す

#### blink
機能としては大したものではないが、パターンを渡してその通りに点滅して欲しかったので個別の機能にした  
8bitの数を下のbitから順に読み出して1/16秒おきに切り替える  
1/16秒待つ動作は1/0.000032=31250より31250/16回WAITして実現している

#### play
まず人間の耳が聞こえる限界の周波数と言われているのが20kHzである  
繰り返しの中で一番重要な処理は波形生成であり、処理速度に起因する音が聞こえないようにするためには繰り返しを毎秒20000回以上行う必要がある  
今回は毎秒31250回行うが、これは繰り返しの最後にWAITを書くだけで実現できる  
そして繰り返しの中の処理は256クロック以内に完了しなければならない  
さもなくば全体的に音が下がることになる

楽譜データは比較的大きいため直接メモリには展開せずに必要な時にメモリに読み出す機能(PROGMEM)を使用する  
読み出したデータは目的毎に各変数に振り分ける  
前に読み出した音符が終了すると再びデータを読み出す

波形生成は読み出してからの経過時間と周波数のデータを比較することでパルス波を生成する  
パルス波は比較だけで波形生成ができるので処理時間が短く済む

音の減衰は1未満の数を繰り返し掛けることで指数関数的な減衰を実現する  
ビットシフトと減算のみで作っているため一定の音量に達するとそれ以上小さくはならない

#### 初期設定
レジスタと呼ばれる場所に所定の値をを書き込むことで特定の効果を得ることができる
ここではピンの設定、タイマーやPWMの有効化、不要な機能の無効化を行う

### 楽譜データの作成
楽譜データはバイナリで打ち込むのは難しいため、MMLで打ち込んでデータに変換する  
MMLは文字で楽譜を表現する方法の総称であり、今回用いるのは製作する電子オルゴールの制約を満たす独自の記法である
変換プログラムはJavaScriptで記述したためWebページから使用することができる

## 資料
- [MML変換](https://mcbeeringi.github.io/t85_musicbox/)
- [プログラム本体](https://github.com/McbeEringi/t85_musicbox/tree/main/musicbox)
- PWM ![pwm](https://user-images.githubusercontent.com/46889548/197172081-691eb744-3eea-490f-9f6d-8c7cd249ee4b.jpeg)
- 回路 ![schematic](https://user-images.githubusercontent.com/46889548/197172166-205e3b4b-485f-437b-a8ab-d9a513e34d4d.jpeg)
